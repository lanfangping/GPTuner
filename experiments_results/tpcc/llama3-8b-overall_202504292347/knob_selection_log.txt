[2025-04-29 23:47:21,456 INFO] [knob_selection.py:select_on_system_level:58] select_on_system_level - 0th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['DateStyle', 'IntervalStyle', 'TimeZone', 'allow_in_place_tablespaces', 'allow_system_table_mods', 'application_name', 'archive_cleanup_command', 'archive_command', 'archive_mode', 'archive_timeout', 'array_nulls', 'authentication_timeout', 'autovacuum', 'autovacuum_analyze_scale_factor', 'autovacuum_analyze_threshold', 'autovacuum_freeze_max_age', 'autovacuum_max_workers', 'autovacuum_multixact_freeze_max_age', 'autovacuum_naptime', 'autovacuum_vacuum_cost_delay', 'autovacuum_vacuum_cost_limit', 'autovacuum_vacuum_insert_scale_factor', 'autovacuum_vacuum_insert_threshold', 'autovacuum_vacuum_scale_factor', 'autovacuum_vacuum_threshold', 'autovacuum_work_mem', 'backend_flush_after', 'backslash_quote', 'backtrace_functions', 'bgwriter_delay']
DBMS: postgres;
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:47:33,238 INFO] [knob_selection.py:select_on_system_level:60] select_on_system_level - 0th response: {'knob_list': [{'DateStyle': 0.0}, {'IntervalStyle': 0.0}, {'TimeZone': 0.0}, {'allow_in_place_tablespaces': 0.0}, {'allow_system_table_mods': 0.0}, {'application_name': 0.0}, {'archive_cleanup_command': 0.0}, {'archive_command': 0.2}, {'archive_mode': 0.3}, {'archive_timeout': 0.2}, {'array_nulls': 0.0}, {'authentication_timeout': 0.2}, {'autovacuum': 0.8}, {'autovacuum_analyze_scale_factor': 0.7}, {'autovacuum_analyze_threshold': 0.7}, {'autovacuum_freeze_max_age': 0.7}, {'autovacuum_max_workers': 0.8}, {'autovacuum_multixact_freeze_max_age': 0.7}, {'autovacuum_naptime': 0.6}, {'autovacuum_vacuum_cost_delay': 0.6}, {'autovacuum_vacuum_cost_limit': 0.6}, {'autovacuum_vacuum_insert_scale_factor': 0.6}, {'autovacuum_vacuum_insert_threshold': 0.6}, {'autovacuum_vacuum_scale_factor': 0.6}, {'autovacuum_vacuum_threshold': 0.6}, {'autovacuum_work_mem': 0.9}, {'backend_flush_after': 0.5}, {'backslash_quote': 0.0}, {'backtrace_functions': 0.0}, {'bgwriter_delay': 0.4}]}
[2025-04-29 23:47:33,432 INFO] [knob_selection.py:select_on_system_level:58] select_on_system_level - 30th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['bgwriter_flush_after', 'bgwriter_lru_maxpages', 'bgwriter_lru_multiplier', 'block_size', 'bonjour', 'bonjour_name', 'bytea_output', 'check_function_bodies', 'checkpoint_completion_target', 'checkpoint_flush_after', 'checkpoint_timeout', 'checkpoint_warning', 'client_connection_check_interval', 'client_encoding', 'client_min_messages', 'cluster_name', 'commit_delay', 'commit_siblings', 'compute_query_id', 'config_file', 'constraint_exclusion', 'cpu_index_tuple_cost', 'cpu_operator_cost', 'cpu_tuple_cost', 'cursor_tuple_fraction', 'data_checksums', 'data_directory', 'data_directory_mode', 'data_sync_retry', 'db_user_namespace']
DBMS: postgres;
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:47:57,484 INFO] [knob_selection.py:select_on_system_level:60] select_on_system_level - 30th response: {'knob_list': ['checkpoint_completion_target', {'score': 0.8}, 'checkpoint_flush_after', {'score': 0.7}, 'checkpoint_timeout', {'score': 0.6}, 'checkpoint_warning', {'score': 0.5}, 'cpu_index_tuple_cost', {'score': 0.8}, 'cpu_operator_cost', {'score': 0.8}, 'cpu_tuple_cost', {'score': 0.8}, 'cursor_tuple_fraction', {'score': 0.7}, 'data_checksums', {'score': 0.6}, 'shared_buffers', {'score': 0.9}, 'effective_cache_size', {'score': 0.9}, 'maintenance_work_mem', {'score': 0.8}, 'autovacuum_vacuum_scale_factor', {'score': 0.7}, 'autovacuum_vacuum_scale_factor', {'score': 0.7}, 'autovacuum_analyze_scale_factor', {'score': 0.7}, 'autovacuum_vacuum_threshold', {'score': 0.6}, 'autovacuum_analyze_threshold', {'score': 0.6}, 'autovacuum_vacuum_insert_threshold', {'score': 0.6}, 'autovacuum_vacuum_delete_threshold', {'score': 0.6}, 'autovacuum_vacuum_merge_threshold', {'score': 0.6}, 'autovacuum_vacuum_squeeze_threshold', {'score': 0.6}, 'autovacuum_vacuum_truncate_threshold', {'score': 0.6}, 'autovacuum_freeze_max_age', {'score': 0.5}, 'autovacuum_vacuum_cost_delay', {'score': 0.5}, 'autovacuum_vacuum_cost_limit', {'score': 0.5}, 'autovacuum_vacuum_scale_factor', {'score': 0.7}, 'autovacuum_analyze_scale_factor', {'score': 0.7}, 'autovacuum_vacuum_threshold', {'score': 0.6}, 'autovacuum_analyze_threshold', {'score': 0.6}, 'autovacuum_vacuum_insert_threshold', {'score': 0.6}, 'autovacuum_vacuum_delete_threshold', {'score': 0.6}, 'autovacuum_vacuum_merge_threshold', {'score': 0.6}, 'autovacuum_vacuum_squeeze_threshold', {'score': 0.6}, 'autovacuum_vacuum_truncate_threshold', {'score': 0.6}, 'autovacuum_freeze_max_age', {'score': 0.5}, 'autovacuum_vacuum_cost_delay', {'score': 0.5}, 'autovacuum_vacuum_cost_limit', {'score': 0.5}, 'bgwriter_flush_after', {'score': 0.4}, 'bgwriter_lru_maxpages', {'score': 0.4}, 'bgwriter_lru_multiplier', {'score': 0.4}, 'block_size', {'score': 0.3}, 'bonjour', {'score': 0}, 'bonjour_name', {'score': 0}, 'bytea_output', {'score': 0}, 'check_function_bodies', {'score': 0}, 'client_connection_check_interval', {'score': 0}, 'client_encoding', {'score': 0}, 'client_min_messages', {'score': 0}, 'cluster_name', {'score': 0}, 'commit_delay', {'score': 0}, 'commit_siblings', {'score': 0}, 'compute_query_id', {'score': 0}, 'config_file', {'score': 0}, 'constraint_exclusion', {'score': 0}, 'data_directory', {'score': 0}, 'data_directory_mode', {'score': 0}, 'data_sync_retry', {'score': 0}, 'db_user_namespace', {'score': 0}]}
[2025-04-29 23:47:57,485 INFO] [knob_selection.py:select_on_system_level:58] select_on_system_level - 60th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['deadlock_timeout', 'debug_assertions', 'debug_discard_caches', 'debug_pretty_print', 'debug_print_parse', 'debug_print_plan', 'debug_print_rewritten', 'default_statistics_target', 'default_table_access_method', 'default_tablespace', 'default_text_search_config', 'default_toast_compression', 'default_transaction_deferrable', 'default_transaction_isolation', 'default_transaction_read_only', 'dynamic_library_path', 'dynamic_shared_memory_type', 'effective_cache_size', 'effective_io_concurrency', 'enable_async_append', 'enable_bitmapscan', 'enable_gathermerge', 'enable_hashagg', 'enable_hashjoin', 'enable_incremental_sort', 'enable_indexonlyscan', 'enable_indexscan', 'enable_material', 'enable_memoize', 'enable_mergejoin']
DBMS: postgres;
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:48:07,253 INFO] [knob_selection.py:select_on_system_level:60] select_on_system_level - 60th response: {'knob_list': ['effective_cache_size', 0.9, 'effective_io_concurrency', 0.8, 'default_statistics_target', 0.7, 'enable_bitmapscan', 0.6, 'enable_gathermerge', 0.6, 'enable_hashagg', 0.6, 'enable_hashjoin', 0.6, 'enable_incremental_sort', 0.6, 'enable_indexonlyscan', 0.6, 'enable_indexscan', 0.6, 'enable_mergejoin', 0.6, 'enable_material', 0.5, 'enable_memoize', 0.5, 'default_transaction_isolation', 0.4, 'default_transaction_read_only', 0.4, 'default_transaction_deferrable', 0.4, 'default_toast_compression', 0.3, 'default_tablespace', 0.2, 'default_table_access_method', 0.2, 'default_text_search_config', 0.2, 'dynamic_shared_memory_type', 0.1, 'dynamic_library_path', 0.1, 'debug_print_plan', 0.1, 'debug_print_rewritten', 0.1, 'debug_print_parse', 0.1, 'debug_pretty_print', 0.1, 'debug_discard_caches', 0.1, 'debug_assertions', 0.1, 'enable_async_append', 0.1, 'enable_indexonlyscan', 0.1, 'deadlock_timeout', 0.1]}
[2025-04-29 23:48:07,253 INFO] [knob_selection.py:select_on_system_level:58] select_on_system_level - 90th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['enable_nestloop', 'enable_parallel_append', 'enable_parallel_hash', 'enable_partition_pruning', 'enable_partitionwise_aggregate', 'enable_partitionwise_join', 'enable_seqscan', 'enable_sort', 'enable_tidscan', 'escape_string_warning', 'event_source', 'exit_on_error', 'extension_destdir', 'external_pid_file', 'extra_float_digits', 'force_parallel_mode', 'from_collapse_limit', 'fsync', 'full_page_writes', 'geqo', 'geqo_effort', 'geqo_generations', 'geqo_pool_size', 'geqo_seed', 'geqo_selection_bias', 'geqo_threshold', 'gin_fuzzy_search_limit', 'gin_pending_list_limit', 'hash_mem_multiplier', 'hba_file']
DBMS: postgres;
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:48:16,743 INFO] [knob_selection.py:select_on_system_level:60] select_on_system_level - 90th response: {'knob_list': ['fsync', 0.9, 'full_page_writes', 0.8, 'geqo', 0.8, 'geqo_effort', 0.8, 'geqo_generations', 0.8, 'geqo_pool_size', 0.8, 'geqo_seed', 0.8, 'geqo_selection_bias', 0.8, 'geqo_threshold', 0.8, 'hash_mem_multiplier', 0.8, 'enable_parallel_append', 0.7, 'enable_parallel_hash', 0.7, 'enable_partition_pruning', 0.7, 'enable_partitionwise_aggregate', 0.7, 'enable_partitionwise_join', 0.7, 'enable_sort', 0.7, 'from_collapse_limit', 0.6, 'gin_fuzzy_search_limit', 0.6, 'gin_pending_list_limit', 0.6, 'escape_string_warning', 0.4, 'event_source', 0.4, 'exit_on_error', 0.4, 'extension_destdir', 0.4, 'external_pid_file', 0.4, 'extra_float_digits', 0.4, 'force_parallel_mode', 0.4, 'hba_file', 0.4, 'enable_nestloop', 0.3, 'enable_tidscan', 0.3, 'enable_seqscan', 0.2]}
[2025-04-29 23:48:16,743 INFO] [knob_selection.py:select_on_system_level:58] select_on_system_level - 120th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['hot_standby', 'hot_standby_feedback', 'huge_page_size', 'huge_pages', 'ident_file', 'idle_in_transaction_session_timeout', 'idle_session_timeout', 'ignore_checksum_failure', 'ignore_invalid_pages', 'ignore_system_indexes', 'in_hot_standby', 'integer_datetimes', 'jit', 'jit_above_cost', 'jit_debugging_support', 'jit_dump_bitcode', 'jit_expressions', 'jit_inline_above_cost', 'jit_optimize_above_cost', 'jit_profiling_support', 'jit_provider', 'jit_tuple_deforming', 'join_collapse_limit', 'krb_caseins_users', 'krb_server_keyfile', 'lc_collate', 'lc_ctype', 'lc_messages', 'lc_monetary', 'lc_numeric']
DBMS: postgres;
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:48:31,134 INFO] [knob_selection.py:select_on_system_level:60] select_on_system_level - 120th response: {'knob_list': [{'knob_name': 'huge_page_size', 'score': 0.9}, {'knob_name': 'huge_pages', 'score': 0.9}, {'knob_name': 'jit', 'score': 0.8}, {'knob_name': 'jit_above_cost', 'score': 0.8}, {'knob_name': 'jit_optimize_above_cost', 'score': 0.8}, {'knob_name': 'join_collapse_limit', 'score': 0.7}, {'knob_name': 'idle_in_transaction_session_timeout', 'score': 0.6}, {'knob_name': 'idle_session_timeout', 'score': 0.6}, {'knob_name': 'ignore_checksum_failure', 'score': 0.5}, {'knob_name': 'ignore_invalid_pages', 'score': 0.5}, {'knob_name': 'krb_caseins_users', 'score': 0.4}, {'knob_name': 'krb_server_keyfile', 'score': 0.4}, {'knob_name': 'lc_collate', 'score': 0.3}, {'knob_name': 'lc_ctype', 'score': 0.3}, {'knob_name': 'lc_messages', 'score': 0.3}, {'knob_name': 'lc_monetary', 'score': 0.3}, {'knob_name': 'lc_numeric', 'score': 0.3}, {'knob_name': 'integer_datetimes', 'score': 0.2}, {'knob_name': 'jit_dump_bitcode', 'score': 0.2}, {'knob_name': 'jit_expressions', 'score': 0.2}, {'knob_name': 'jit_inline_above_cost', 'score': 0.2}, {'knob_name': 'jit_profiling_support', 'score': 0.2}, {'knob_name': 'jit_provider', 'score': 0.2}, {'knob_name': 'jit_tuple_deforming', 'score': 0.2}, {'knob_name': 'jit_debugging_support', 'score': 0.2}, {'knob_name': 'hot_standby', 'score': 0.1}, {'knob_name': 'hot_standby_feedback', 'score': 0.1}, {'knob_name': 'in_hot_standby', 'score': 0.1}, {'knob_name': 'ignore_system_indexes', 'score': 0.1}, {'knob_name': 'ident_file', 'score': 0.1}]}
[2025-04-29 23:48:31,135 INFO] [knob_selection.py:select_on_system_level:58] select_on_system_level - 150th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['lc_time', 'listen_addresses', 'lo_compat_privileges', 'local_preload_libraries', 'lock_timeout', 'log_autovacuum_min_duration', 'log_checkpoints', 'log_connections', 'log_destination', 'log_directory', 'log_disconnections', 'log_duration', 'log_error_verbosity', 'log_executor_stats', 'log_file_mode', 'log_filename', 'log_hostname', 'log_line_prefix', 'log_lock_waits', 'log_min_duration_sample', 'log_min_duration_statement', 'log_min_error_statement', 'log_min_messages', 'log_parameter_max_length', 'log_parameter_max_length_on_error', 'log_parser_stats', 'log_planner_stats', 'log_recovery_conflict_waits', 'log_replication_commands', 'log_rotation_age']
DBMS: postgres;
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:58:46,085 INFO] [knob_selection.py:select_on_system_level:60] select_on_system_level - 150th response: {'knob_list': [{'knob_name': 'log_autovacuum_min_duration', 'score': 0.9}, {'knob_name': 'log_checkpoints', 'score': 0.8}, {'knob_name': 'log_connections', 'score': 0.7}, {'knob_name': 'log_disconnections', 'score': 0.7}, {'knob_name': 'log_duration', 'score': 0.7}, {'knob_name': 'log_lock_waits', 'score': 0.7}, {'knob_name': 'log_min_duration_sample', 'score': 0.7}, {'knob_name': 'log_min_duration_statement', 'score': 0.7}, {'knob_name': 'log_min_error_statement', 'score': 0.7}, {'knob_name': 'log_min_messages', 'score': 0.6}, {'knob_name': 'log_parameter_max_length', 'score': 0.6}, {'knob_name': 'log_parameter_max_length_on_error', 'score': 0.6}, {'knob_name': 'log_rotation_age', 'score': 0.6}, {'knob_name': 'log_replication_commands', 'score': 0.5}, {'knob_name': 'log_recovery_conflict_waits', 'score': 0.5}, {'knob_name': 'log_executor_stats', 'score': 0.4}, {'knob_name': 'log_parser_stats', 'score': 0.4}, {'knob_name': 'log_planner_stats', 'score': 0.4}, {'knob_name': 'log_line_prefix', 'score': 0.3}, {'knob_name': 'log_destination', 'score': 0.3}, {'knob_name': 'log_directory', 'score': 0.3}, {'knob_name': 'log_filename', 'score': 0.3}, {'knob_name': 'log_file_mode', 'score': 0.3}, {'knob_name': 'log_hostname', 'score': 0.3}, {'knob_name': 'log_error_verbosity', 'score': 0.2}, {'knob_name': 'lock_timeout', 'score': 0.2}, {'knob_name': 'local_preload_libraries', 'score': 0.1}, {'knob_name': 'lo_compat_privileges', 'score': 0.1}, {'knob_name': 'lc_time', 'score': 0.1}, {'knob_name': 'listen_addresses', 'score': 0.1}]}
[2025-04-29 23:58:46,086 INFO] [knob_selection.py:select_on_system_level:58] select_on_system_level - 180th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['log_rotation_size', 'log_statement', 'log_statement_sample_rate', 'log_statement_stats', 'log_temp_files', 'log_timezone', 'log_transaction_sample_rate', 'log_truncate_on_rotation', 'logging_collector', 'logical_decoding_work_mem', 'maintenance_io_concurrency', 'maintenance_work_mem', 'max_connections', 'max_files_per_process', 'max_function_args', 'max_identifier_length', 'max_index_keys', 'max_locks_per_transaction', 'max_logical_replication_workers', 'max_parallel_maintenance_workers', 'max_parallel_workers', 'max_parallel_workers_per_gather', 'max_pred_locks_per_page', 'max_pred_locks_per_relation', 'max_pred_locks_per_transaction', 'max_prepared_transactions', 'max_replication_slots', 'max_slot_wal_keep_size', 'max_stack_depth', 'max_standby_archive_delay']
DBMS: postgres;
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:58:55,191 INFO] [knob_selection.py:select_on_system_level:60] select_on_system_level - 180th response: {'knob_list': [{'log_statement': 0.8}, {'log_statement_stats': 0.8}, {'log_transaction_sample_rate': 0.8}, {'maintenance_io_concurrency': 0.7}, {'maintenance_work_mem': 0.7}, {'max_connections': 0.7}, {'max_locks_per_transaction': 0.7}, {'max_logical_replication_workers': 0.7}, {'max_parallel_maintenance_workers': 0.7}, {'max_parallel_workers': 0.7}, {'max_parallel_workers_per_gather': 0.7}, {'max_pred_locks_per_page': 0.7}, {'max_pred_locks_per_relation': 0.7}, {'max_pred_locks_per_transaction': 0.7}, {'max_prepared_transactions': 0.7}, {'max_replication_slots': 0.7}, {'max_slot_wal_keep_size': 0.7}, {'max_stack_depth': 0.7}, {'max_standby_archive_delay': 0.7}, {'logical_decoding_work_mem': 0.6}, {'logging_collector': 0.5}, {'log_rotation_size': 0.2}, {'log_statement_sample_rate': 0.2}, {'log_temp_files': 0.2}, {'log_timezone': 0.2}, {'log_truncate_on_rotation': 0.2}, {'max_files_per_process': 0.2}, {'max_function_args': 0.2}, {'max_identifier_length': 0.2}, {'max_index_keys': 0.2}]}
[2025-04-29 23:58:55,192 INFO] [knob_selection.py:select_on_system_level:58] select_on_system_level - 210th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['max_standby_streaming_delay', 'max_sync_workers_per_subscription', 'max_wal_senders', 'max_wal_size', 'max_worker_processes', 'min_dynamic_shared_memory', 'min_parallel_index_scan_size', 'min_parallel_table_scan_size', 'min_wal_size', 'old_snapshot_threshold', 'parallel_leader_participation', 'parallel_setup_cost', 'parallel_tuple_cost', 'password_encryption', 'pg_stat_statements.max', 'pg_stat_statements.save', 'pg_stat_statements.track', 'pg_stat_statements.track_planning', 'pg_stat_statements.track_utility', 'plan_cache_mode', 'port', 'post_auth_delay', 'pre_auth_delay', 'primary_conninfo', 'primary_slot_name', 'promote_trigger_file', 'quote_all_identifiers', 'random_page_cost', 'recovery_end_command', 'recovery_init_sync_method']
DBMS: postgres;
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:59:04,093 INFO] [knob_selection.py:select_on_system_level:60] select_on_system_level - 210th response: {'knob_list': ['max_wal_senders', 0.9, 'max_wal_size', 0.8, 'min_wal_size', 0.7, 'max_standby_streaming_delay', 0.6, 'min_dynamic_shared_memory', 0.5, 'min_parallel_index_scan_size', 0.5, 'min_parallel_table_scan_size', 0.5, 'random_page_cost', 0.4, 'parallel_leader_participation', 0.4, 'parallel_setup_cost', 0.3, 'parallel_tuple_cost', 0.3, 'plan_cache_mode', 0.2, 'pg_stat_statements.max', 0.2, 'pg_stat_statements.save', 0.2, 'pg_stat_statements.track', 0.2, 'pg_stat_statements.track_planning', 0.2, 'pg_stat_statements.track_utility', 0.2, 'quote_all_identifiers', 0.1, 'port', 0.1, 'post_auth_delay', 0.1, 'pre_auth_delay', 0.1, 'primary_conninfo', 0.1, 'primary_slot_name', 0.1, 'promote_trigger_file', 0.1, 'recovery_end_command', 0.1, 'recovery_init_sync_method', 0.1, 'max_sync_workers_per_subscription', 0.1, 'old_snapshot_threshold', 0.1, 'password_encryption', 0.1]}
[2025-04-29 23:59:04,094 INFO] [knob_selection.py:select_on_system_level:58] select_on_system_level - 240th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['recovery_min_apply_delay', 'recovery_target', 'recovery_target_action', 'recovery_target_inclusive', 'recovery_target_lsn', 'recovery_target_name', 'recovery_target_time', 'recovery_target_timeline', 'recovery_target_xid', 'remove_temp_files_after_crash', 'restart_after_crash', 'restore_command', 'row_security', 'search_path', 'segment_size', 'seq_page_cost', 'server_encoding', 'server_version', 'server_version_num', 'session_preload_libraries', 'session_replication_role', 'shared_buffers', 'shared_memory_type', 'shared_preload_libraries', 'ssl', 'ssl_ca_file', 'ssl_cert_file', 'ssl_ciphers', 'ssl_crl_dir', 'ssl_crl_file']
DBMS: postgres;
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:59:12,245 INFO] [knob_selection.py:select_on_system_level:60] select_on_system_level - 240th response: {'knob_list': [{'recovery_min_apply_delay': 0.8}, {'shared_buffers': 0.9}, {'shared_preload_libraries': 0.7}, {'session_preload_libraries': 0.7}, {'row_security': 0.6}, {'segment_size': 0.5}, {'seq_page_cost': 0.4}, {'server_encoding': 0.2}, {'server_version': 0.2}, {'server_version_num': 0.2}, {'ssl': 0.1}, {'ssl_ca_file': 0.1}, {'ssl_cert_file': 0.1}, {'ssl_ciphers': 0.1}, {'ssl_crl_dir': 0.1}, {'ssl_crl_file': 0.1}, {'search_path': 0.1}, {'remove_temp_files_after_crash': 0.1}, {'restart_after_crash': 0.1}, {'restore_command': 0.1}, {'recovery_target_action': 0.1}, {'recovery_target_inclusive': 0.1}, {'recovery_target_lsn': 0.1}, {'recovery_target_name': 0.1}, {'recovery_target_time': 0.1}, {'recovery_target_timeline': 0.1}, {'recovery_target_xid': 0.1}, {'shared_memory_type': 0.1}]}
[2025-04-29 23:59:12,245 INFO] [knob_selection.py:select_on_system_level:58] select_on_system_level - 270th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['ssl_dh_params_file', 'ssl_ecdh_curve', 'ssl_key_file', 'ssl_library', 'ssl_max_protocol_version', 'ssl_min_protocol_version', 'ssl_passphrase_command', 'ssl_passphrase_command_supports_reload', 'ssl_prefer_server_ciphers', 'standard_conforming_strings', 'statement_timeout', 'stats_temp_directory', 'superuser_reserved_connections', 'synchronize_seqscans', 'synchronous_commit', 'synchronous_standby_names', 'syslog_facility', 'syslog_ident', 'syslog_sequence_numbers', 'syslog_split_messages', 'tcp_keepalives_count', 'tcp_keepalives_idle', 'tcp_keepalives_interval', 'tcp_user_timeout', 'temp_buffers', 'temp_file_limit', 'temp_tablespaces', 'timezone_abbreviations', 'trace_notify', 'trace_recovery_messages']
DBMS: postgres;
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:59:18,509 INFO] [knob_selection.py:select_on_system_level:60] select_on_system_level - 270th response: {'knob_list': [{'ssl_max_protocol_version': 0.6, 'ssl_min_protocol_version': 0.6, 'ssl_prefer_server_ciphers': 0.8, 'statement_timeout': 0.9, 'stats_temp_directory': 0.4, 'superuser_reserved_connections': 0.7, 'synchronize_seqscans': 0.5, 'synchronous_commit': 0.6, 'synchronous_standby_names': 0.7, 'tcp_keepalives_count': 0.4, 'tcp_keepalives_idle': 0.4, 'tcp_keepalives_interval': 0.4, 'tcp_user_timeout': 0.4, 'temp_buffers': 0.8, 'temp_file_limit': 0.7, 'temp_tablespaces': 0.5, 'timezone_abbreviations': 0.3, 'trace_notify': 0.4, 'trace_recovery_messages': 0.5}]}
[2025-04-29 23:59:18,510 INFO] [knob_selection.py:select_on_system_level:58] select_on_system_level - 300th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['trace_sort', 'track_activities', 'track_activity_query_size', 'track_commit_timestamp', 'track_counts', 'track_functions', 'track_io_timing', 'track_wal_io_timing', 'transaction_deferrable', 'transaction_isolation', 'transaction_read_only', 'transform_null_equals', 'unix_socket_directories', 'unix_socket_group', 'unix_socket_permissions', 'update_process_title', 'vacuum_cost_delay', 'vacuum_cost_limit', 'vacuum_cost_page_dirty', 'vacuum_cost_page_hit', 'vacuum_cost_page_miss', 'vacuum_defer_cleanup_age', 'vacuum_failsafe_age', 'vacuum_freeze_min_age', 'vacuum_freeze_table_age', 'vacuum_multixact_failsafe_age', 'vacuum_multixact_freeze_min_age', 'vacuum_multixact_freeze_table_age', 'wal_block_size', 'wal_buffers']
DBMS: postgres;
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:59:31,460 INFO] [knob_selection.py:select_on_system_level:60] select_on_system_level - 300th response: {'knob_list': ['vacuum_cost_page_hit', {'score': 0.9}, 'vacuum_cost_page_miss', {'score': 0.9}, 'vacuum_cost_page_dirty', {'score': 0.8}, 'vacuum_cost_limit', {'score': 0.8}, 'vacuum_cost_delay', {'score': 0.7}, 'vacuum_defer_cleanup_age', {'score': 0.7}, 'vacuum_failsafe_age', {'score': 0.7}, 'vacuum_freeze_min_age', {'score': 0.7}, 'vacuum_freeze_table_age', {'score': 0.7}, 'vacuum_multixact_failsafe_age', {'score': 0.7}, 'vacuum_multixact_freeze_min_age', {'score': 0.7}, 'vacuum_multixact_freeze_table_age', {'score': 0.7}, 'wal_block_size', {'score': 0.6}, 'wal_buffers', {'score': 0.6}, 'transaction_isolation', {'score': 0.5}, 'transaction_read_only', {'score': 0.5}, 'transaction_deferrable', {'score': 0.4}, 'update_process_title', {'score': 0.4}, 'trace_sort', {'score': 0.3}, 'track_activities', {'score': 0.3}, 'track_activity_query_size', {'score': 0.3}, 'track_commit_timestamp', {'score': 0.3}, 'track_counts', {'score': 0.3}, 'track_functions', {'score': 0.3}, 'track_io_timing', {'score': 0.3}, 'track_wal_io_timing', {'score': 0.3}, 'unix_socket_directories', {'score': 0.2}, 'unix_socket_group', {'score': 0.2}, 'unix_socket_permissions', {'score': 0.2}, 'transform_null_equals', {'score': 0.1}]}
[2025-04-29 23:59:31,461 INFO] [knob_selection.py:select_on_system_level:58] select_on_system_level - 330th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['wal_compression', 'wal_consistency_checking', 'wal_init_zero', 'wal_keep_size', 'wal_level', 'wal_log_hints', 'wal_receiver_create_temp_slot', 'wal_receiver_status_interval', 'wal_receiver_timeout', 'wal_recycle', 'wal_retrieve_retry_interval', 'wal_segment_size', 'wal_sender_timeout', 'wal_skip_threshold', 'wal_sync_method', 'wal_writer_delay', 'wal_writer_flush_after', 'work_mem', 'xmlbinary', 'xmloption', 'zero_damaged_pages']
DBMS: postgres;
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:59:37,872 INFO] [knob_selection.py:select_on_system_level:60] select_on_system_level - 330th response: {'wal_compression': 0.5, 'wal_consistency_checking': 0.1, 'wal_init_zero': 0.1, 'wal_keep_size': 0.7, 'wal_level': 0.8, 'wal_log_hints': 0.2, 'wal_receiver_create_temp_slot': 0.1, 'wal_receiver_status_interval': 0.1, 'wal_receiver_timeout': 0.1, 'wal_recycle': 0.1, 'wal_retrieve_retry_interval': 0.1, 'wal_segment_size': 0.8, 'wal_sender_timeout': 0.1, 'wal_skip_threshold': 0.1, 'wal_sync_method': 0.7, 'wal_writer_delay': 0.8, 'wal_writer_flush_after': 0.8, 'work_mem': 0.9, 'xmlbinary': 0.1, 'xmloption': 0.1, 'zero_damaged_pages': 0.1}
[2025-04-29 23:59:37,873 INFO] [knob_selection.py:select_on_workload_level:83] select_on_workload_level - 0th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Which knobs are important heavily depends on the workload type because different workloads result in different performance bottleneck.Given the workload type, analyze and identify the important knobs that significantly impact database performance when such workload is deployed.  Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['DateStyle', 'IntervalStyle', 'TimeZone', 'allow_in_place_tablespaces', 'allow_system_table_mods', 'application_name', 'archive_cleanup_command', 'archive_command', 'archive_mode', 'archive_timeout', 'array_nulls', 'authentication_timeout', 'autovacuum', 'autovacuum_analyze_scale_factor', 'autovacuum_analyze_threshold', 'autovacuum_freeze_max_age', 'autovacuum_max_workers', 'autovacuum_multixact_freeze_max_age', 'autovacuum_naptime', 'autovacuum_vacuum_cost_delay', 'autovacuum_vacuum_cost_limit', 'autovacuum_vacuum_insert_scale_factor', 'autovacuum_vacuum_insert_threshold', 'autovacuum_vacuum_scale_factor', 'autovacuum_vacuum_threshold', 'autovacuum_work_mem', 'backend_flush_after', 'backslash_quote', 'backtrace_functions', 'bgwriter_delay']
DBMS: postgres;
WORKLOAD TYPE:OLTP
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:59:47,139 INFO] [knob_selection.py:select_on_workload_level:85] select_on_workload_level - 0th response: {'knob_list': {'allow_in_place_tablespaces': 0.2, 'allow_system_table_mods': 0.1, 'application_name': 0.0, 'archive_cleanup_command': 0.0, 'archive_command': 0.0, 'archive_mode': 0.0, 'archive_timeout': 0.0, 'array_nulls': 0.0, 'authentication_timeout': 0.0, 'autovacuum': 0.8, 'autovacuum_analyze_scale_factor': 0.7, 'autovacuum_analyze_threshold': 0.7, 'autovacuum_freeze_max_age': 0.7, 'autovacuum_max_workers': 0.8, 'autovacuum_multixact_freeze_max_age': 0.7, 'autovacuum_naptime': 0.6, 'autovacuum_vacuum_cost_delay': 0.5, 'autovacuum_vacuum_cost_limit': 0.6, 'autovacuum_vacuum_insert_scale_factor': 0.6, 'autovacuum_vacuum_insert_threshold': 0.6, 'autovacuum_vacuum_scale_factor': 0.8, 'autovacuum_vacuum_threshold': 0.7, 'autovacuum_work_mem': 0.9, 'backend_flush_after': 0.4, 'backslash_quote': 0.0, 'backtrace_functions': 0.0, 'bgwriter_delay': 0.8}}
[2025-04-29 23:59:47,140 INFO] [knob_selection.py:select_on_workload_level:83] select_on_workload_level - 30th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Which knobs are important heavily depends on the workload type because different workloads result in different performance bottleneck.Given the workload type, analyze and identify the important knobs that significantly impact database performance when such workload is deployed.  Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['bgwriter_flush_after', 'bgwriter_lru_maxpages', 'bgwriter_lru_multiplier', 'block_size', 'bonjour', 'bonjour_name', 'bytea_output', 'check_function_bodies', 'checkpoint_completion_target', 'checkpoint_flush_after', 'checkpoint_timeout', 'checkpoint_warning', 'client_connection_check_interval', 'client_encoding', 'client_min_messages', 'cluster_name', 'commit_delay', 'commit_siblings', 'compute_query_id', 'config_file', 'constraint_exclusion', 'cpu_index_tuple_cost', 'cpu_operator_cost', 'cpu_tuple_cost', 'cursor_tuple_fraction', 'data_checksums', 'data_directory', 'data_directory_mode', 'data_sync_retry', 'db_user_namespace']
DBMS: postgres;
WORKLOAD TYPE:OLTP
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-29 23:59:55,552 INFO] [knob_selection.py:select_on_workload_level:85] select_on_workload_level - 30th response: {'knob_list': {'bgwriter_flush_after': 0.8, 'bgwriter_lru_maxpages': 0.7, 'bgwriter_lru_multiplier': 0.6, 'block_size': 0.4, 'bonjour': 0, 'bonjour_name': 0, 'bytea_output': 0, 'check_function_bodies': 0, 'checkpoint_completion_target': 0.9, 'checkpoint_flush_after': 0.8, 'checkpoint_timeout': 0.5, 'checkpoint_warning': 0.5, 'client_connection_check_interval': 0, 'client_encoding': 0, 'client_min_messages': 0, 'cluster_name': 0, 'commit_delay': 0.6, 'commit_siblings': 0.6, 'compute_query_id': 0, 'config_file': 0, 'constraint_exclusion': 0, 'cpu_index_tuple_cost': 0.3, 'cpu_operator_cost': 0.3, 'cpu_tuple_cost': 0.3, 'cursor_tuple_fraction': 0.2, 'data_checksums': 0.8, 'data_directory': 0, 'data_directory_mode': 0, 'data_sync_retry': 0.9, 'db_user_namespace': 0}}
[2025-04-29 23:59:55,553 INFO] [knob_selection.py:select_on_workload_level:83] select_on_workload_level - 60th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Which knobs are important heavily depends on the workload type because different workloads result in different performance bottleneck.Given the workload type, analyze and identify the important knobs that significantly impact database performance when such workload is deployed.  Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['deadlock_timeout', 'debug_assertions', 'debug_discard_caches', 'debug_pretty_print', 'debug_print_parse', 'debug_print_plan', 'debug_print_rewritten', 'default_statistics_target', 'default_table_access_method', 'default_tablespace', 'default_text_search_config', 'default_toast_compression', 'default_transaction_deferrable', 'default_transaction_isolation', 'default_transaction_read_only', 'dynamic_library_path', 'dynamic_shared_memory_type', 'effective_cache_size', 'effective_io_concurrency', 'enable_async_append', 'enable_bitmapscan', 'enable_gathermerge', 'enable_hashagg', 'enable_hashjoin', 'enable_incremental_sort', 'enable_indexonlyscan', 'enable_indexscan', 'enable_material', 'enable_memoize', 'enable_mergejoin']
DBMS: postgres;
WORKLOAD TYPE:OLTP
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-30 00:00:03,493 INFO] [knob_selection.py:select_on_workload_level:85] select_on_workload_level - 60th response: {'knob_list': [{'deadlock_timeout': 0.1}, {'debug_assertions': 0}, {'debug_discard_caches': 0}, {'debug_pretty_print': 0}, {'debug_print_parse': 0}, {'debug_print_plan': 0}, {'debug_print_rewritten': 0}, {'default_statistics_target': 0.6}, {'default_table_access_method': 0}, {'default_tablespace': 0}, {'default_text_search_config': 0}, {'default_toast_compression': 0}, {'default_transaction_deferrable': 0}, {'default_transaction_isolation': 0}, {'default_transaction_read_only': 0}, {'dynamic_library_path': 0}, {'dynamic_shared_memory_type': 0}, {'effective_cache_size': 0.8}, {'effective_io_concurrency': 0.7}, {'enable_async_append': 0}, {'enable_bitmapscan': 0.4}, {'enable_gathermerge': 0.4}, {'enable_hashagg': 0.4}, {'enable_hashjoin': 0.6}, {'enable_incremental_sort': 0.5}, {'enable_indexonlyscan': 0.6}, {'enable_indexscan': 0.5}, {'enable_material': 0}, {'enable_memoize': 0}, {'enable_mergejoin': 0.4}]}
[2025-04-30 00:00:03,494 INFO] [knob_selection.py:select_on_workload_level:83] select_on_workload_level - 90th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Which knobs are important heavily depends on the workload type because different workloads result in different performance bottleneck.Given the workload type, analyze and identify the important knobs that significantly impact database performance when such workload is deployed.  Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['enable_nestloop', 'enable_parallel_append', 'enable_parallel_hash', 'enable_partition_pruning', 'enable_partitionwise_aggregate', 'enable_partitionwise_join', 'enable_seqscan', 'enable_sort', 'enable_tidscan', 'escape_string_warning', 'event_source', 'exit_on_error', 'extension_destdir', 'external_pid_file', 'extra_float_digits', 'force_parallel_mode', 'from_collapse_limit', 'fsync', 'full_page_writes', 'geqo', 'geqo_effort', 'geqo_generations', 'geqo_pool_size', 'geqo_seed', 'geqo_selection_bias', 'geqo_threshold', 'gin_fuzzy_search_limit', 'gin_pending_list_limit', 'hash_mem_multiplier', 'hba_file']
DBMS: postgres;
WORKLOAD TYPE:OLTP
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-30 00:10:13,487 INFO] [knob_selection.py:select_on_workload_level:85] select_on_workload_level - 90th response: {'knob_list': {'enable_nestloop': 0.6, 'enable_parallel_append': 0.2, 'enable_parallel_hash': 0.4, 'enable_partition_pruning': 0.8, 'enable_partitionwise_aggregate': 0.9, 'enable_partitionwise_join': 0.9, 'enable_seqscan': 0.4, 'enable_sort': 0.6, 'enable_tidscan': 0.2, 'escape_string_warning': 0.0, 'event_source': 0.0, 'exit_on_error': 0.0, 'extension_destdir': 0.0, 'external_pid_file': 0.0, 'extra_float_digits': 0.0, 'force_parallel_mode': 0.5, 'from_collapse_limit': 0.0, 'fsync': 0.0, 'full_page_writes': 0.0, 'geqo': 0.8, 'geqo_effort': 0.7, 'geqo_generations': 0.7, 'geqo_pool_size': 0.7, 'geqo_seed': 0.0, 'geqo_selection_bias': 0.0, 'geqo_threshold': 0.0, 'gin_fuzzy_search_limit': 0.0, 'gin_pending_list_limit': 0.0, 'hash_mem_multiplier': 0.0, 'hba_file': 0.0}}
[2025-04-30 00:10:13,488 INFO] [knob_selection.py:select_on_workload_level:83] select_on_workload_level - 120th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Which knobs are important heavily depends on the workload type because different workloads result in different performance bottleneck.Given the workload type, analyze and identify the important knobs that significantly impact database performance when such workload is deployed.  Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['hot_standby', 'hot_standby_feedback', 'huge_page_size', 'huge_pages', 'ident_file', 'idle_in_transaction_session_timeout', 'idle_session_timeout', 'ignore_checksum_failure', 'ignore_invalid_pages', 'ignore_system_indexes', 'in_hot_standby', 'integer_datetimes', 'jit', 'jit_above_cost', 'jit_debugging_support', 'jit_dump_bitcode', 'jit_expressions', 'jit_inline_above_cost', 'jit_optimize_above_cost', 'jit_profiling_support', 'jit_provider', 'jit_tuple_deforming', 'join_collapse_limit', 'krb_caseins_users', 'krb_server_keyfile', 'lc_collate', 'lc_ctype', 'lc_messages', 'lc_monetary', 'lc_numeric']
DBMS: postgres;
WORKLOAD TYPE:OLTP
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-30 00:10:22,802 INFO] [knob_selection.py:select_on_workload_level:85] select_on_workload_level - 120th response: {'knob_list': {'huge_page_size': 0.8, 'huge_pages': 0.8, 'join_collapse_limit': 0.7, 'jit': 0.6, 'jit_above_cost': 0.6, 'jit_inline_above_cost': 0.6, 'jit_optimize_above_cost': 0.6, 'jit_profiling_support': 0.6, 'jit_provider': 0.6, 'jit_tuple_deforming': 0.6, 'idle_in_transaction_session_timeout': 0.5, 'idle_session_timeout': 0.5, 'integer_datetimes': 0.5, 'krb_caseins_users': 0.5, 'krb_server_keyfile': 0.5, 'lc_collate': 0.5, 'lc_ctype': 0.5, 'lc_messages': 0.5, 'lc_monetary': 0.5, 'lc_numeric': 0.5, 'ignore_checksum_failure': 0.4, 'ignore_invalid_pages': 0.4, 'ignore_system_indexes': 0.4, 'in_hot_standby': 0.4, 'hot_standby': 0.3, 'hot_standby_feedback': 0.3, 'jit_dump_bitcode': 0.3, 'jit_expressions': 0.3, 'jit_debugging_support': 0.2, 'ident_file': 0.2}}
[2025-04-30 00:10:22,803 INFO] [knob_selection.py:select_on_workload_level:83] select_on_workload_level - 150th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Which knobs are important heavily depends on the workload type because different workloads result in different performance bottleneck.Given the workload type, analyze and identify the important knobs that significantly impact database performance when such workload is deployed.  Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['lc_time', 'listen_addresses', 'lo_compat_privileges', 'local_preload_libraries', 'lock_timeout', 'log_autovacuum_min_duration', 'log_checkpoints', 'log_connections', 'log_destination', 'log_directory', 'log_disconnections', 'log_duration', 'log_error_verbosity', 'log_executor_stats', 'log_file_mode', 'log_filename', 'log_hostname', 'log_line_prefix', 'log_lock_waits', 'log_min_duration_sample', 'log_min_duration_statement', 'log_min_error_statement', 'log_min_messages', 'log_parameter_max_length', 'log_parameter_max_length_on_error', 'log_parser_stats', 'log_planner_stats', 'log_recovery_conflict_waits', 'log_replication_commands', 'log_rotation_age']
DBMS: postgres;
WORKLOAD TYPE:OLTP
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-30 00:10:32,185 INFO] [knob_selection.py:select_on_workload_level:85] select_on_workload_level - 150th response: {'knob_list': {'lock_timeout': 0.8, 'log_min_duration_sample': 0.7, 'log_min_duration_statement': 0.7, 'log_min_error_statement': 0.6, 'log_min_messages': 0.6, 'log_lock_waits': 0.5, 'log_duration': 0.5, 'log_error_verbosity': 0.4, 'log_connections': 0.4, 'log_disconnections': 0.4, 'log_replication_commands': 0.3, 'log_recovery_conflict_waits': 0.2, 'log_rotation_age': 0.2, 'log_filename': 0.1, 'log_file_mode': 0.1, 'log_line_prefix': 0.1, 'log_hostname': 0.1, 'log_destination': 0.1, 'log_directory': 0.1, 'log_autovacuum_min_duration': 0.1, 'log_checkpoints': 0.1, 'log_executor_stats': 0.1, 'log_parser_stats': 0.1, 'log_planner_stats': 0.1, 'log_parameter_max_length': 0.1, 'log_parameter_max_length_on_error': 0.1, 'lo_compat_privileges': 0.0, 'local_preload_libraries': 0.0, 'lc_time': 0.0, 'listen_addresses': 0.0}}
[2025-04-30 00:10:32,186 INFO] [knob_selection.py:select_on_workload_level:83] select_on_workload_level - 180th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Which knobs are important heavily depends on the workload type because different workloads result in different performance bottleneck.Given the workload type, analyze and identify the important knobs that significantly impact database performance when such workload is deployed.  Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['log_rotation_size', 'log_statement', 'log_statement_sample_rate', 'log_statement_stats', 'log_temp_files', 'log_timezone', 'log_transaction_sample_rate', 'log_truncate_on_rotation', 'logging_collector', 'logical_decoding_work_mem', 'maintenance_io_concurrency', 'maintenance_work_mem', 'max_connections', 'max_files_per_process', 'max_function_args', 'max_identifier_length', 'max_index_keys', 'max_locks_per_transaction', 'max_logical_replication_workers', 'max_parallel_maintenance_workers', 'max_parallel_workers', 'max_parallel_workers_per_gather', 'max_pred_locks_per_page', 'max_pred_locks_per_relation', 'max_pred_locks_per_transaction', 'max_prepared_transactions', 'max_replication_slots', 'max_slot_wal_keep_size', 'max_stack_depth', 'max_standby_archive_delay']
DBMS: postgres;
WORKLOAD TYPE:OLTP
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-30 00:10:40,046 INFO] [knob_selection.py:select_on_workload_level:85] select_on_workload_level - 180th response: {'knob_list': {'log_rotation_size': 0, 'log_statement': 0, 'log_statement_sample_rate': 0, 'log_statement_stats': 0, 'log_temp_files': 0, 'log_timezone': 0, 'log_transaction_sample_rate': 0, 'log_truncate_on_rotation': 0, 'logging_collector': 0, 'logical_decoding_work_mem': 0.8, 'maintenance_io_concurrency': 0.6, 'maintenance_work_mem': 0.8, 'max_connections': 0.9, 'max_files_per_process': 0, 'max_function_args': 0, 'max_identifier_length': 0, 'max_index_keys': 0, 'max_locks_per_transaction': 0, 'max_logical_replication_workers': 0, 'max_parallel_maintenance_workers': 0, 'max_parallel_workers': 0, 'max_parallel_workers_per_gather': 0, 'max_pred_locks_per_page': 0, 'max_pred_locks_per_relation': 0, 'max_pred_locks_per_transaction': 0, 'max_prepared_transactions': 0, 'max_replication_slots': 0, 'max_slot_wal_keep_size': 0, 'max_stack_depth': 0, 'max_standby_archive_delay': 0}}
[2025-04-30 00:10:40,047 INFO] [knob_selection.py:select_on_workload_level:83] select_on_workload_level - 210th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Which knobs are important heavily depends on the workload type because different workloads result in different performance bottleneck.Given the workload type, analyze and identify the important knobs that significantly impact database performance when such workload is deployed.  Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['max_standby_streaming_delay', 'max_sync_workers_per_subscription', 'max_wal_senders', 'max_wal_size', 'max_worker_processes', 'min_dynamic_shared_memory', 'min_parallel_index_scan_size', 'min_parallel_table_scan_size', 'min_wal_size', 'old_snapshot_threshold', 'parallel_leader_participation', 'parallel_setup_cost', 'parallel_tuple_cost', 'password_encryption', 'pg_stat_statements.max', 'pg_stat_statements.save', 'pg_stat_statements.track', 'pg_stat_statements.track_planning', 'pg_stat_statements.track_utility', 'plan_cache_mode', 'port', 'post_auth_delay', 'pre_auth_delay', 'primary_conninfo', 'primary_slot_name', 'promote_trigger_file', 'quote_all_identifiers', 'random_page_cost', 'recovery_end_command', 'recovery_init_sync_method']
DBMS: postgres;
WORKLOAD TYPE:OLTP
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-30 00:10:49,655 INFO] [knob_selection.py:select_on_workload_level:85] select_on_workload_level - 210th response: {'knob_list': [{'max_wal_senders': 0.8}, {'max_worker_processes': 0.7}, {'min_wal_size': 0.8}, {'max_standby_streaming_delay': 0.4}, {'min_parallel_index_scan_size': 0.6}, {'min_parallel_table_scan_size': 0.6}, {'random_page_cost': 0.5}, {'parallel_leader_participation': 0.5}, {'parallel_tuple_cost': 0.5}, {'parallel_setup_cost': 0.5}, {'pg_stat_statements.max': 0.5}, {'pg_stat_statements.save': 0.5}, {'pg_stat_statements.track': 0.5}, {'pg_stat_statements.track_planning': 0.5}, {'pg_stat_statements.track_utility': 0.5}, {'plan_cache_mode': 0.5}, {'quote_all_identifiers': 0.5}, {'port': 0.2}, {'post_auth_delay': 0.2}, {'pre_auth_delay': 0.2}, {'primary_conninfo': 0.2}, {'primary_slot_name': 0.2}, {'promote_trigger_file': 0.2}, {'recovery_end_command': 0.2}, {'recovery_init_sync_method': 0.2}, {'old_snapshot_threshold': 0.3}, {'max_sync_workers_per_subscription': 0.3}, {'max_sync_workers_per_subscription': 0.3}, {'min_dynamic_shared_memory': 0.3}]}
[2025-04-30 00:10:49,656 INFO] [knob_selection.py:select_on_workload_level:83] select_on_workload_level - 240th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Which knobs are important heavily depends on the workload type because different workloads result in different performance bottleneck.Given the workload type, analyze and identify the important knobs that significantly impact database performance when such workload is deployed.  Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['recovery_min_apply_delay', 'recovery_target', 'recovery_target_action', 'recovery_target_inclusive', 'recovery_target_lsn', 'recovery_target_name', 'recovery_target_time', 'recovery_target_timeline', 'recovery_target_xid', 'remove_temp_files_after_crash', 'restart_after_crash', 'restore_command', 'row_security', 'search_path', 'segment_size', 'seq_page_cost', 'server_encoding', 'server_version', 'server_version_num', 'session_preload_libraries', 'session_replication_role', 'shared_buffers', 'shared_memory_type', 'shared_preload_libraries', 'ssl', 'ssl_ca_file', 'ssl_cert_file', 'ssl_ciphers', 'ssl_crl_dir', 'ssl_crl_file']
DBMS: postgres;
WORKLOAD TYPE:OLTP
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-30 00:20:59,487 INFO] [knob_selection.py:select_on_workload_level:85] select_on_workload_level - 240th response: {'knob_list': {'recovery_min_apply_delay': 0.0, 'recovery_target': 0.0, 'recovery_target_action': 0.0, 'recovery_target_inclusive': 0.0, 'recovery_target_lsn': 0.0, 'recovery_target_name': 0.0, 'recovery_target_time': 0.0, 'recovery_target_timeline': 0.0, 'recovery_target_xid': 0.0, 'remove_temp_files_after_crash': 0.0, 'restart_after_crash': 0.0, 'restore_command': 0.0, 'row_security': 0.0, 'search_path': 0.0, 'segment_size': 0.0, 'seq_page_cost': 0.0, 'server_encoding': 0.0, 'server_version': 0.0, 'server_version_num': 0.0, 'session_preload_libraries': 0.0, 'session_replication_role': 0.0, 'shared_buffers': 0.8, 'shared_memory_type': 0.0, 'shared_preload_libraries': 0.0, 'ssl': 0.0, 'ssl_ca_file': 0.0, 'ssl_cert_file': 0.0, 'ssl_ciphers': 0.0, 'ssl_crl_dir': 0.0, 'ssl_crl_file': 0.0}}
[2025-04-30 00:20:59,488 INFO] [knob_selection.py:select_on_workload_level:83] select_on_workload_level - 270th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Which knobs are important heavily depends on the workload type because different workloads result in different performance bottleneck.Given the workload type, analyze and identify the important knobs that significantly impact database performance when such workload is deployed.  Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['ssl_dh_params_file', 'ssl_ecdh_curve', 'ssl_key_file', 'ssl_library', 'ssl_max_protocol_version', 'ssl_min_protocol_version', 'ssl_passphrase_command', 'ssl_passphrase_command_supports_reload', 'ssl_prefer_server_ciphers', 'standard_conforming_strings', 'statement_timeout', 'stats_temp_directory', 'superuser_reserved_connections', 'synchronize_seqscans', 'synchronous_commit', 'synchronous_standby_names', 'syslog_facility', 'syslog_ident', 'syslog_sequence_numbers', 'syslog_split_messages', 'tcp_keepalives_count', 'tcp_keepalives_idle', 'tcp_keepalives_interval', 'tcp_user_timeout', 'temp_buffers', 'temp_file_limit', 'temp_tablespaces', 'timezone_abbreviations', 'trace_notify', 'trace_recovery_messages']
DBMS: postgres;
WORKLOAD TYPE:OLTP
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-30 00:31:08,409 INFO] [knob_selection.py:select_on_workload_level:85] select_on_workload_level - 270th response: {'knob_list': [{'ssl_dh_params_file': 0}, {'ssl_ecdh_curve': 0}, {'ssl_key_file': 0}, {'ssl_library': 0}, {'ssl_max_protocol_version': 0}, {'ssl_min_protocol_version': 0}, {'ssl_passphrase_command': 0}, {'ssl_passphrase_command_supports_reload': 0}, {'ssl_prefer_server_ciphers': 0}, {'standard_conforming_strings': 0}, {'statement_timeout': 0.8}, {'stats_temp_directory': 0}, {'superuser_reserved_connections': 0}, {'synchronize_seqscans': 0.2}, {'synchronous_commit': 0.5}, {'synchronous_standby_names': 0}, {'syslog_facility': 0}, {'syslog_ident': 0}, {'syslog_sequence_numbers': 0}, {'syslog_split_messages': 0}, {'tcp_keepalives_count': 0}, {'tcp_keepalives_idle': 0}, {'tcp_keepalives_interval': 0}, {'tcp_user_timeout': 0}, {'temp_buffers': 0.7}, {'temp_file_limit': 0}, {'temp_tablespaces': 0}, {'timezone_abbreviations': 0}, {'trace_notify': 0}, {'trace_recovery_messages': 0}]}
[2025-04-30 00:31:08,410 INFO] [knob_selection.py:select_on_workload_level:83] select_on_workload_level - 300th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Which knobs are important heavily depends on the workload type because different workloads result in different performance bottleneck.Given the workload type, analyze and identify the important knobs that significantly impact database performance when such workload is deployed.  Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['trace_sort', 'track_activities', 'track_activity_query_size', 'track_commit_timestamp', 'track_counts', 'track_functions', 'track_io_timing', 'track_wal_io_timing', 'transaction_deferrable', 'transaction_isolation', 'transaction_read_only', 'transform_null_equals', 'unix_socket_directories', 'unix_socket_group', 'unix_socket_permissions', 'update_process_title', 'vacuum_cost_delay', 'vacuum_cost_limit', 'vacuum_cost_page_dirty', 'vacuum_cost_page_hit', 'vacuum_cost_page_miss', 'vacuum_defer_cleanup_age', 'vacuum_failsafe_age', 'vacuum_freeze_min_age', 'vacuum_freeze_table_age', 'vacuum_multixact_failsafe_age', 'vacuum_multixact_freeze_min_age', 'vacuum_multixact_freeze_table_age', 'wal_block_size', 'wal_buffers']
DBMS: postgres;
WORKLOAD TYPE:OLTP
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-30 00:31:17,718 INFO] [knob_selection.py:select_on_workload_level:85] select_on_workload_level - 300th response: {'knob_list': {'trace_sort': 0.0, 'track_activities': 0.0, 'track_activity_query_size': 0.0, 'track_commit_timestamp': 0.0, 'track_counts': 0.2, 'track_functions': 0.0, 'track_io_timing': 0.0, 'track_wal_io_timing': 0.0, 'transaction_deferrable': 0.0, 'transaction_isolation': 0.0, 'transaction_read_only': 0.0, 'transform_null_equals': 0.0, 'unix_socket_directories': 0.0, 'unix_socket_group': 0.0, 'unix_socket_permissions': 0.0, 'update_process_title': 0.0, 'vacuum_cost_delay': 0.0, 'vacuum_cost_limit': 0.0, 'vacuum_cost_page_dirty': 0.0, 'vacuum_cost_page_hit': 0.0, 'vacuum_cost_page_miss': 0.0, 'vacuum_defer_cleanup_age': 0.0, 'vacuum_failsafe_age': 0.0, 'vacuum_freeze_min_age': 0.0, 'vacuum_freeze_table_age': 0.0, 'vacuum_multixact_failsafe_age': 0.0, 'vacuum_multixact_freeze_min_age': 0.0, 'vacuum_multixact_freeze_table_age': 0.0, 'wal_block_size': 0.0, 'wal_buffers': 0.6}}
[2025-04-30 00:31:17,718 INFO] [knob_selection.py:select_on_workload_level:83] select_on_workload_level - 330th prompt: 
You are an experienced DBA and your will determine which knobs are worth tuning. You only tune knobs that have a significant impact on DBMS performance and the target DBMS is postgres. Which knobs are important heavily depends on the workload type because different workloads result in different performance bottleneck.Given the workload type, analyze and identify the important knobs that significantly impact database performance when such workload is deployed.  Given the following candidate knobs, score the importance for each knob between 0 and 1, with a higher value indicating that it is more likey to impact postgres performance significantly. 
Candidate knobs: ['wal_compression', 'wal_consistency_checking', 'wal_init_zero', 'wal_keep_size', 'wal_level', 'wal_log_hints', 'wal_receiver_create_temp_slot', 'wal_receiver_status_interval', 'wal_receiver_timeout', 'wal_recycle', 'wal_retrieve_retry_interval', 'wal_segment_size', 'wal_sender_timeout', 'wal_skip_threshold', 'wal_sync_method', 'wal_writer_delay', 'wal_writer_flush_after', 'work_mem', 'xmlbinary', 'xmloption', 'zero_damaged_pages']
DBMS: postgres;
WORKLOAD TYPE:OLTP
Now let us think step by step and give me your scoring of all the candidate knobs in json format:
{
    "knob_name": {score}    // fill "score" with a number between 0 and 1
}
If no knobs are suggested, just fill "knob_list" with "None" and also return result in json format. 

[2025-04-30 00:31:24,671 INFO] [knob_selection.py:select_on_workload_level:85] select_on_workload_level - 330th response: {'knob_list': ['work_mem', 'wal_writer_flush_after', 'wal_writer_delay', 'wal_sync_method', 'wal_segment_size', 'wal_recycle', 'wal_receiver_timeout', 'wal_receiver_status_interval', 'wal_receiver_create_temp_slot', 'wal_log_hints', 'wal_keep_size', 'wal_init_zero', 'wal_consistency_checking', 'wal_compression'], 'knob_scores': {'work_mem': 0.9, 'wal_writer_flush_after': 0.8, 'wal_writer_delay': 0.8, 'wal_sync_method': 0.7, 'wal_segment_size': 0.7, 'wal_recycle': 0.6, 'wal_receiver_timeout': 0.6, 'wal_receiver_status_interval': 0.5, 'wal_receiver_create_temp_slot': 0.5, 'wal_log_hints': 0.5, 'wal_keep_size': 0.5, 'wal_init_zero': 0.4, 'wal_consistency_checking': 0.4, 'wal_compression': 0.4}}
